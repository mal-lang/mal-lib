<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Lexer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">MAL lib</a> &gt; <a href="index.source.html" class="el_package">org.mal_lang.lib</a> &gt; <span class="el_source">Lexer.java</span></div><h1>Lexer.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2019-2022 Foreseeti AB &lt;https://foreseeti.com&gt;
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.mal_lang.lib;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;

public class Lexer {
  private MalLogger LOGGER;
  private String filename;
  private byte[] input;
  private int index;
  private int line;
  private int col;
  private int startLine;
  private int startCol;
  private List&lt;Byte&gt; lexeme;
<span class="fc" id="L39">  private List&lt;Token&gt; comments = new ArrayList&lt;&gt;();</span>
  private boolean eof;

  private static Map&lt;String, TokenType&gt; keywords;

  static {
<span class="fc" id="L45">    keywords = new HashMap&lt;&gt;();</span>
<span class="fc" id="L46">    keywords.put(&quot;include&quot;, TokenType.INCLUDE);</span>
<span class="fc" id="L47">    keywords.put(&quot;info&quot;, TokenType.INFO);</span>
<span class="fc" id="L48">    keywords.put(&quot;category&quot;, TokenType.CATEGORY);</span>
<span class="fc" id="L49">    keywords.put(&quot;abstract&quot;, TokenType.ABSTRACT);</span>
<span class="fc" id="L50">    keywords.put(&quot;asset&quot;, TokenType.ASSET);</span>
<span class="fc" id="L51">    keywords.put(&quot;extends&quot;, TokenType.EXTENDS);</span>
<span class="fc" id="L52">    keywords.put(&quot;associations&quot;, TokenType.ASSOCIATIONS);</span>
<span class="fc" id="L53">    keywords.put(&quot;let&quot;, TokenType.LET);</span>
<span class="fc" id="L54">    keywords.put(&quot;E&quot;, TokenType.EXIST);</span>
<span class="fc" id="L55">    keywords.put(&quot;C&quot;, TokenType.C);</span>
<span class="fc" id="L56">    keywords.put(&quot;I&quot;, TokenType.I);</span>
<span class="fc" id="L57">    keywords.put(&quot;A&quot;, TokenType.A);</span>
  }

  private static Map&lt;String, Byte&gt; escapeSequences;

  static {
<span class="fc" id="L63">    escapeSequences = new HashMap&lt;&gt;();</span>
<span class="fc" id="L64">    escapeSequences.put(&quot;\\b&quot;, (byte) '\b');</span>
<span class="fc" id="L65">    escapeSequences.put(&quot;\\n&quot;, (byte) '\n');</span>
<span class="fc" id="L66">    escapeSequences.put(&quot;\\t&quot;, (byte) '\t');</span>
<span class="fc" id="L67">    escapeSequences.put(&quot;\\r&quot;, (byte) '\r');</span>
<span class="fc" id="L68">    escapeSequences.put(&quot;\\f&quot;, (byte) '\f');</span>
<span class="fc" id="L69">    escapeSequences.put(&quot;\\\&quot;&quot;, (byte) '&quot;');</span>
<span class="fc" id="L70">    escapeSequences.put(&quot;\\\\&quot;, (byte) '\\');</span>
<span class="fc" id="L71">  }</span>

  public Lexer(File file) throws IOException {
<span class="fc" id="L74">    this(file, file.getName(), false, false);</span>
<span class="fc" id="L75">  }</span>

  public Lexer(File file, boolean verbose, boolean debug) throws IOException {
<span class="nc" id="L78">    this(file, file.getName(), verbose, debug);</span>
<span class="nc" id="L79">  }</span>

  public Lexer(File file, String relativeName) throws IOException {
<span class="fc" id="L82">    this(file, relativeName, false, false);</span>
<span class="fc" id="L83">  }</span>

<span class="fc" id="L85">  public Lexer(File file, String relativeName, boolean verbose, boolean debug) throws IOException {</span>
<span class="fc" id="L86">    Locale.setDefault(Locale.ROOT);</span>
<span class="fc" id="L87">    LOGGER = new MalLogger(&quot;LEXER&quot;, verbose, debug);</span>
    try {
<span class="fc" id="L89">      LOGGER.debug(String.format(&quot;Creating lexer with file '%s'&quot;, relativeName));</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">      if (!file.exists()) {</span>
<span class="fc" id="L91">        throw new IOException(String.format(&quot;%s: No such file or directory&quot;, relativeName));</span>
      }
<span class="fc" id="L93">      this.filename = relativeName;</span>
<span class="fc" id="L94">      this.input = Files.readAllBytes(file.toPath());</span>
<span class="fc" id="L95">      this.index = 0;</span>
<span class="fc" id="L96">      this.line = 1;</span>
<span class="fc" id="L97">      this.col = 1;</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">      this.eof = input.length == 0;</span>
<span class="fc" id="L99">    } catch (IOException e) {</span>
<span class="fc" id="L100">      LOGGER.print();</span>
<span class="fc" id="L101">      throw e;</span>
<span class="fc" id="L102">    }</span>
<span class="fc" id="L103">  }</span>

  public static boolean syntacticallyEqual(Lexer l1, Lexer l2) {
    try {
<span class="nc" id="L107">      var tok1 = l1.next();</span>
<span class="nc" id="L108">      var tok2 = l2.next();</span>
<span class="nc bnc" id="L109" title="All 4 branches missed.">      while (tok1.type != TokenType.EOF &amp;&amp; tok2.type != TokenType.EOF) {</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">        if (tok1.type != tok2.type</span>
<span class="nc bnc" id="L111" title="All 6 branches missed.">            || !tok1.stringValue.equals(tok2.stringValue)</span>
            || tok1.intValue != tok2.intValue
            || tok1.doubleValue != tok2.doubleValue) {
<span class="nc" id="L114">          return false;</span>
        }
<span class="nc" id="L116">        tok1 = l1.next();</span>
<span class="nc" id="L117">        tok2 = l2.next();</span>
      }
<span class="nc bnc" id="L119" title="All 4 branches missed.">      return tok1.type == TokenType.EOF &amp;&amp; tok2.type == TokenType.EOF;</span>
<span class="nc" id="L120">    } catch (CompilerException e) {</span>
<span class="nc" id="L121">      return false;</span>
    }
  }

  private String getLexemeString() {
<span class="fc" id="L126">    byte[] byteArray = new byte[lexeme.size()];</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">    for (int i = 0; i &lt; lexeme.size(); i++) {</span>
<span class="fc" id="L128">      byteArray[i] = lexeme.get(i).byteValue();</span>
    }
<span class="fc" id="L130">    return new String(byteArray, StandardCharsets.UTF_8);</span>
  }

  public Token next() throws CompilerException {
<span class="fc" id="L134">    startLine = line;</span>
<span class="fc" id="L135">    startCol = col;</span>
<span class="fc" id="L136">    lexeme = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">    if (eof) {</span>
<span class="fc" id="L138">      LOGGER.print();</span>
<span class="fc" id="L139">      return createToken(TokenType.EOF);</span>
    }
<span class="fc" id="L141">    byte c = consume();</span>
<span class="fc bfc" id="L142" title="All 25 branches covered.">    switch (c) {</span>
      case ' ':
      case '\t':
      case '\r':
      case '\n':
<span class="fc" id="L147">        return next();</span>
      case '#':
<span class="fc" id="L149">        return createToken(TokenType.HASH);</span>
      case ':':
<span class="fc" id="L151">        return createToken(TokenType.COLON);</span>
      case '{':
<span class="fc" id="L153">        return createToken(TokenType.LCURLY);</span>
      case '}':
<span class="fc" id="L155">        return createToken(TokenType.RCURLY);</span>
      case '+':
<span class="fc bfc" id="L157" title="All 2 branches covered.">        if (peek('&gt;')) {</span>
<span class="fc" id="L158">          consume();</span>
<span class="fc" id="L159">          return createToken(TokenType.INHERIT);</span>
        } else {
<span class="fc" id="L161">          return createToken(TokenType.PLUS);</span>
        }
      case '-':
<span class="fc bfc" id="L164" title="All 2 branches covered.">        if (peek('&gt;')) {</span>
<span class="fc" id="L165">          consume();</span>
<span class="fc" id="L166">          return createToken(TokenType.OVERRIDE);</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">        } else if (peek(&quot;-&gt;&quot;)) {</span>
<span class="fc" id="L168">          consume(2);</span>
<span class="fc" id="L169">          return createToken(TokenType.RARROW);</span>
        } else {
<span class="fc" id="L171">          return createToken(TokenType.MINUS);</span>
        }
      case '&amp;':
<span class="fc" id="L174">        return createToken(TokenType.ALL);</span>
      case '|':
<span class="fc" id="L176">        return createToken(TokenType.ANY);</span>
      case '!':
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">        if (peek('E')) {</span>
<span class="fc" id="L179">          consume();</span>
<span class="fc" id="L180">          return createToken(TokenType.NOTEXIST);</span>
        } else {
<span class="nc" id="L182">          throw exception(&quot;Expected 'E'&quot;);</span>
        }
      case '@':
<span class="fc" id="L185">        return createToken(TokenType.AT);</span>
      case '[':
<span class="fc" id="L187">        return createToken(TokenType.LBRACKET);</span>
      case ']':
<span class="fc" id="L189">        return createToken(TokenType.RBRACKET);</span>
      case '(':
<span class="fc" id="L191">        return createToken(TokenType.LPAREN);</span>
      case ')':
<span class="fc" id="L193">        return createToken(TokenType.RPAREN);</span>
      case ',':
<span class="fc" id="L195">        return createToken(TokenType.COMMA);</span>
      case '&lt;':
<span class="fc bfc" id="L197" title="All 2 branches covered.">        if (peek(&quot;--&quot;)) {</span>
<span class="fc" id="L198">          consume(2);</span>
<span class="fc" id="L199">          return createToken(TokenType.LARROW);</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">        } else if (peek('-')) {</span>
<span class="fc" id="L201">          consume();</span>
<span class="fc" id="L202">          return createToken(TokenType.REQUIRE);</span>
        } else {
<span class="fc" id="L204">          throw exception(&quot;Expected '-' or '--'&quot;);</span>
        }
      case '=':
<span class="fc" id="L207">        return createToken(TokenType.ASSIGN);</span>
      case '\\':
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">        if (peek('/')) {</span>
<span class="fc" id="L210">          consume();</span>
<span class="fc" id="L211">          return createToken(TokenType.UNION);</span>
        } else {
<span class="nc" id="L213">          throw exception(&quot;Expected '/'&quot;);</span>
        }
      case '/':
<span class="fc bfc" id="L216" title="All 2 branches covered.">        if (peek('\\')) {</span>
<span class="fc" id="L217">          consume();</span>
<span class="fc" id="L218">          return createToken(TokenType.INTERSECT);</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">        } else if (peek('/')) {</span>
<span class="pc bpc" id="L220" title="2 of 6 branches missed.">          while (!eof &amp;&amp; !peek('\n') &amp;&amp; !peek('\r')) {</span>
<span class="fc" id="L221">            consume();</span>
          }
<span class="fc" id="L223">          createComment(TokenType.SINGLECOMMENT);</span>
<span class="fc" id="L224">          return next();</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">        } else if (peek('*')) {</span>
<span class="fc" id="L226">          consume();</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">          while (!peek(&quot;*/&quot;)) {</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">            if (eof) {</span>
<span class="fc" id="L229">              throw exception(</span>
<span class="fc" id="L230">                  String.format(</span>
                      &quot;Unterminated comment starting at %s&quot;,
                      new Position(filename, startLine, startCol)));
            }
<span class="fc" id="L234">            consume();</span>
          }
<span class="fc" id="L236">          consume(2);</span>
<span class="fc" id="L237">          createComment(TokenType.MULTICOMMENT);</span>
<span class="fc" id="L238">          return next();</span>
        } else {
<span class="fc" id="L240">          return createToken(TokenType.DIVIDE);</span>
        }
      case '.':
<span class="fc bfc" id="L243" title="All 2 branches covered.">        if (peek('.')) {</span>
<span class="fc" id="L244">          consume();</span>
<span class="fc" id="L245">          return createToken(TokenType.RANGE);</span>
        } else {
<span class="fc" id="L247">          return createToken(TokenType.DOT);</span>
        }
      case '*':
<span class="fc" id="L250">        return createToken(TokenType.STAR);</span>
      case '^':
<span class="fc" id="L252">        return createToken(TokenType.POWER);</span>
      case '&quot;':
<span class="fc bfc" id="L254" title="All 2 branches covered.">        if (peek(&quot;\&quot;\&quot;&quot;)) {</span>
<span class="fc" id="L255">          consume(2);</span>
<span class="pc bpc" id="L256" title="1 of 4 branches missed.">          while (peek(' ') || peek('\t')) {</span>
<span class="fc" id="L257">            consume();</span>
          }
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">          if (peek('\r')) {</span>
<span class="nc" id="L260">            consume();</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">            if (peek('\n')) {</span>
<span class="nc" id="L262">              consume();</span>
            }
<span class="fc bfc" id="L264" title="All 2 branches covered.">          } else if (peek('\n')) {</span>
<span class="fc" id="L265">            consume();</span>
          } else {
<span class="fc" id="L267">            throw exception(&quot;Expected line terminator&quot;);</span>
          }
<span class="fc" id="L269">          lexeme = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">          while (!peek(&quot;\&quot;\&quot;\&quot;&quot;)) {</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">            if (eof) {</span>
<span class="fc" id="L272">              throw exception(</span>
<span class="fc" id="L273">                  String.format(</span>
                      &quot;Unterminated multi-line string starting at %s&quot;,
                      new Position(filename, startLine, startCol)));
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">            } else if (peek('\r')) {</span>
<span class="nc" id="L277">              consume();</span>
<span class="nc" id="L278">              lexeme = lexeme.subList(0, lexeme.size() - 1);</span>
<span class="nc" id="L279">              lexeme.add((byte) '\n');</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">              if (peek('\n')) {</span>
<span class="nc" id="L281">                consume();</span>
<span class="nc" id="L282">                lexeme = lexeme.subList(0, lexeme.size() - 1);</span>
              }
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">            } else if (peek('\\')) {</span>
<span class="nc" id="L285">              consume();</span>
<span class="nc bnc" id="L286" title="All 4 branches missed.">              if (input[index] &lt; 32 || input[index] &gt; 126) {</span>
<span class="nc" id="L287">                throw exception(String.format(&quot;Invalid escape byte 0x%02X&quot;, input[index]));</span>
              }
<span class="nc" id="L289">              consume();</span>
<span class="nc" id="L290">              var lexemeString = getLexemeString();</span>
<span class="nc" id="L291">              String escapeSequence = lexemeString.substring(lexemeString.length() - 2);</span>
<span class="nc" id="L292">              lexeme = lexeme.subList(0, lexeme.size() - 2);</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">              if (!escapeSequences.containsKey(escapeSequence)) {</span>
<span class="nc" id="L294">                throw exception(String.format(&quot;Invalid escape sequence '%s'&quot;, escapeSequence));</span>
              }
<span class="nc" id="L296">              lexeme.add(escapeSequences.get(escapeSequence));</span>
<span class="nc" id="L297">            } else {</span>
<span class="fc" id="L298">              consume();</span>
            }
          }
<span class="fc" id="L301">          consume(3);</span>
<span class="fc" id="L302">          lexeme = lexeme.subList(0, lexeme.size() - 3);</span>
<span class="fc" id="L303">          return createToken(TokenType.MULTI_STRING);</span>
        }
<span class="fc bfc" id="L305" title="All 2 branches covered.">        while (!peek('&quot;')) {</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">          if (peek('\\')) {</span>
<span class="fc" id="L307">            consume();</span>
<span class="pc bpc" id="L308" title="2 of 4 branches missed.">            if (eof || peek('\n')) {</span>
<span class="nc" id="L309">              throw exception(</span>
<span class="nc" id="L310">                  String.format(</span>
                      &quot;Unterminated string starting at %s&quot;,
                      new Position(filename, startLine, startCol)));
            }
<span class="pc bpc" id="L314" title="1 of 4 branches missed.">            if (input[index] &lt; 32 || input[index] &gt; 126) {</span>
<span class="fc" id="L315">              throw exception(String.format(&quot;Invalid escape byte 0x%02X&quot;, input[index]));</span>
            }
<span class="fc" id="L317">            consume();</span>
<span class="fc" id="L318">            var lexemeString = getLexemeString();</span>
<span class="fc" id="L319">            String escapeSequence = lexemeString.substring(lexemeString.length() - 2);</span>
<span class="fc" id="L320">            lexeme = lexeme.subList(0, lexeme.size() - 2);</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">            if (!escapeSequences.containsKey(escapeSequence)) {</span>
<span class="fc" id="L322">              throw exception(String.format(&quot;Invalid escape sequence '%s'&quot;, escapeSequence));</span>
            }
<span class="fc" id="L324">            lexeme.add(escapeSequences.get(escapeSequence));</span>
<span class="pc bpc" id="L325" title="1 of 4 branches missed.">          } else if (eof || peek('\n')) {</span>
<span class="fc" id="L326">            throw exception(</span>
<span class="fc" id="L327">                String.format(</span>
                    &quot;Unterminated string starting at %s&quot;,
                    new Position(filename, startLine, startCol)));
          } else {
<span class="fc" id="L331">            consume();</span>
          }
        }
<span class="fc" id="L334">        consume();</span>
<span class="fc" id="L335">        return createToken(TokenType.STRING);</span>
      default:
<span class="fc bfc" id="L337" title="All 2 branches covered.">        if (isAlpha(c)) {</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">          while (isAlphaNumeric()) {</span>
<span class="fc" id="L339">            consume();</span>
          }
<span class="fc" id="L341">          var lexemeString = getLexemeString();</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">          if (keywords.containsKey(lexemeString)) {</span>
<span class="fc" id="L343">            return createToken(keywords.get(lexemeString));</span>
          } else {
<span class="fc" id="L345">            return createToken(TokenType.ID);</span>
          }
<span class="fc bfc" id="L347" title="All 2 branches covered.">        } else if (isDigit(c)) {</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">          while (isDigit()) {</span>
<span class="fc" id="L349">            consume();</span>
          }
<span class="fc bfc" id="L351" title="All 4 branches covered.">          if (peek(&quot;..&quot;) || !peek('.')) {</span>
<span class="fc" id="L352">            return createToken(TokenType.INT);</span>
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">          } else if (peek('.')) {</span>
<span class="fc" id="L354">            consume();</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">            while (isDigit()) {</span>
<span class="fc" id="L356">              consume();</span>
            }
<span class="fc" id="L358">            return createToken(TokenType.FLOAT);</span>
          }
        }
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">        if (c &lt; 0) {</span>
<span class="fc" id="L362">          throw exception(String.format(&quot;Unexpected token 0x%02X&quot;, c));</span>
        } else {
<span class="nc" id="L364">          throw exception(String.format(&quot;Unexpected token '%c'&quot;, (char) c));</span>
        }
    }
  }

  private void consume(int n) {
<span class="fc bfc" id="L370" title="All 2 branches covered.">    for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L371">      consume();</span>
    }
<span class="fc" id="L373">  }</span>

  private byte consume() {
<span class="pc bpc" id="L376" title="1 of 2 branches missed.">    if (eof) {</span>
<span class="nc" id="L377">      throw new RuntimeException(&quot;Consuming past end-of-file&quot;);</span>
    }
<span class="fc bfc" id="L379" title="All 2 branches covered.">    if (input[index] == (byte) '\n') {</span>
<span class="fc" id="L380">      line++;</span>
<span class="fc" id="L381">      col = 1;</span>
    } else {
<span class="fc" id="L383">      col++;</span>
    }
<span class="fc" id="L385">    var c = input[index++];</span>
<span class="fc" id="L386">    lexeme.add(c);</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">    if (index == input.length) {</span>
<span class="fc" id="L388">      eof = true;</span>
    }
<span class="fc" id="L390">    return c;</span>
  }

  private boolean peek(String s) {
<span class="fc" id="L394">    var bytes = s.getBytes();</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">    if (input.length - index &lt; bytes.length) {</span>
<span class="fc" id="L396">      return false;</span>
    }
<span class="fc bfc" id="L398" title="All 2 branches covered.">    for (int i = 0; i &lt; bytes.length; i++) {</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">      if (bytes[i] != input[index + i]) {</span>
<span class="fc" id="L400">        return false;</span>
      }
    }
<span class="fc" id="L403">    return true;</span>
  }

  private boolean peek(char c) {
<span class="fc" id="L407">    return peek((byte) c);</span>
  }

  private boolean peek(byte c) {
<span class="pc bpc" id="L411" title="1 of 2 branches missed.">    if (eof) {</span>
<span class="nc" id="L412">      return false;</span>
    } else {
<span class="fc bfc" id="L414" title="All 2 branches covered.">      return c == input[index];</span>
    }
  }

  private void createComment(TokenType type) {
<span class="fc" id="L419">    var lexemeString = getLexemeString();</span>
<span class="fc" id="L420">    lexemeString = lexemeString.substring(2, lexemeString.length());</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">    if (type == TokenType.MULTICOMMENT) {</span>
<span class="fc" id="L422">      lexemeString = lexemeString.substring(0, lexemeString.length() - 2);</span>
    }
<span class="fc" id="L424">    comments.add(new Token(type, filename, startLine, startCol, lexemeString));</span>
<span class="fc" id="L425">  }</span>

  private Token createRawToken(TokenType type) {
<span class="fc bfc" id="L428" title="All 6 branches covered.">    switch (type) {</span>
      case INT:
<span class="fc" id="L430">        return new Token(type, filename, startLine, startCol, Integer.parseInt(getLexemeString()));</span>
      case FLOAT:
<span class="fc" id="L432">        return new Token(</span>
<span class="fc" id="L433">            type, filename, startLine, startCol, Double.parseDouble(getLexemeString()));</span>
      case ID:
<span class="fc" id="L435">        return new Token(type, filename, startLine, startCol, getLexemeString());</span>
      case STRING:
        {
<span class="fc" id="L438">          var lexemeString = getLexemeString();</span>
<span class="fc" id="L439">          return new Token(</span>
              type,
              filename,
              startLine,
              startCol,
<span class="fc" id="L444">              lexemeString.substring(1, lexemeString.length() - 1));</span>
        }
      case MULTI_STRING:
        {
<span class="fc" id="L448">          var lexemeString = getLexemeString();</span>
<span class="fc" id="L449">          var lines = lexemeString.split(&quot;\\R&quot;);</span>

          // Find minIndent
<span class="fc" id="L452">          int minIndent = -1;</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">          for (int i = 0; i &lt; lines.length; i++) {</span>
<span class="fc" id="L454">            var line = lines[i];</span>
<span class="pc bpc" id="L455" title="1 of 4 branches missed.">            if (!line.isBlank() || i + 1 == lines.length) {</span>
<span class="fc" id="L456">              var indent = 0;</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">              for (int j = 0; j &lt; line.length(); j++) {</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">                if (!Character.isWhitespace(line.charAt(j))) {</span>
<span class="fc" id="L459">                  break;</span>
                }
<span class="fc" id="L461">                indent += 1;</span>
              }
<span class="fc bfc" id="L463" title="All 4 branches covered.">              if (minIndent == -1 || indent &lt; minIndent) {</span>
<span class="fc" id="L464">                minIndent = indent;</span>
              }
            }
          }

          // Strip lines
<span class="fc" id="L470">          var newLines = new String[lines.length];</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">          for (int i = 0; i &lt; lines.length; i++) {</span>
<span class="fc" id="L472">            var line = lines[i];</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">            if (line.isBlank()) {</span>
<span class="fc" id="L474">              newLines[i] = &quot;&quot;;</span>
            } else {
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">              if (minIndent != -1) {</span>
<span class="fc" id="L477">                line = line.substring(minIndent);</span>
              }
<span class="fc" id="L479">              newLines[i] = line.stripTrailing();</span>
            }
          }

<span class="fc" id="L483">          return new Token(</span>
<span class="fc" id="L484">              TokenType.STRING, filename, startLine, startCol, String.join(&quot;\n&quot;, newLines));</span>
        }
      default:
<span class="fc" id="L487">        return new Token(type, filename, startLine, startCol);</span>
    }
  }

  @SuppressWarnings(&quot;fallthrough&quot;)
  private void readTrailingComments() throws CompilerException {
    // Trailing comments are all comments followed on the same line as the previous
    // token, including comments that follow previous trailing comments by exactly 1
    // line.
<span class="fc" id="L496">    startLine = line;</span>
<span class="fc" id="L497">    startCol = col;</span>
<span class="fc" id="L498">    lexeme = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L499" title="All 4 branches covered.">    if (eof || peek('\n')) {</span>
<span class="fc" id="L500">      return;</span>
    }
<span class="fc" id="L502">    byte c = consume();</span>
<span class="fc bfc" id="L503" title="All 3 branches covered.">    switch (c) {</span>
      case ' ':
      case '\t':
<span class="fc" id="L506">        readTrailingComments();</span>
<span class="fc" id="L507">        return;</span>
      case '/':
<span class="fc bfc" id="L509" title="All 2 branches covered.">        if (peek('/')) {</span>
<span class="pc bpc" id="L510" title="2 of 6 branches missed.">          while (!eof &amp;&amp; !peek('\n') &amp;&amp; !peek('\r')) {</span>
<span class="fc" id="L511">            consume();</span>
          }
<span class="fc" id="L513">          createComment(TokenType.SINGLECOMMENT);</span>
<span class="pc bpc" id="L514" title="1 of 2 branches missed.">          if (peek(&quot;\r\n&quot;)) {</span>
<span class="nc" id="L515">            consume(2);</span>
<span class="nc" id="L516">            readTrailingComments();</span>
<span class="pc bpc" id="L517" title="1 of 2 branches missed.">          } else if (peek('\n')) {</span>
<span class="fc" id="L518">            consume();</span>
<span class="fc" id="L519">            readTrailingComments();</span>
          }
<span class="fc" id="L521">          return;</span>
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">        } else if (peek('*')) {</span>
<span class="nc" id="L523">          consume();</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">          while (!peek(&quot;*/&quot;)) {</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">            if (eof) {</span>
<span class="nc" id="L526">              throw exception(</span>
<span class="nc" id="L527">                  String.format(</span>
                      &quot;Unterminated comment starting at %s&quot;,
                      new Position(filename, startLine, startCol)));
            }
<span class="nc" id="L531">            consume();</span>
          }
<span class="nc" id="L533">          consume(2);</span>
<span class="nc" id="L534">          createComment(TokenType.MULTICOMMENT);</span>
<span class="nc" id="L535">          readTrailingComments();</span>
<span class="nc" id="L536">          return;</span>
        }
        // Not a comment, we want to fall-through
      default:
<span class="fc" id="L540">        index--;</span>
<span class="fc" id="L541">        col--;</span>
<span class="fc" id="L542">        eof = false;</span>
<span class="fc" id="L543">        return;</span>
    }
  }

  private Token createToken(TokenType type) throws CompilerException {
<span class="fc" id="L548">    var token = createRawToken(type);</span>
<span class="fc" id="L549">    var preComments = List.copyOf(comments);</span>
<span class="fc" id="L550">    comments.clear();</span>
<span class="fc" id="L551">    readTrailingComments();</span>
<span class="fc" id="L552">    var postComments = List.copyOf(comments);</span>
<span class="fc" id="L553">    comments.clear();</span>
<span class="fc" id="L554">    return new Token(token, preComments, postComments);</span>
  }

  private CompilerException exception(String msg) {
<span class="fc" id="L558">    Position pos = null;</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">    if (eof) {</span>
<span class="fc" id="L560">      pos = new Position(filename, line, col);</span>
    } else {
<span class="fc" id="L562">      pos = new Position(filename, startLine, startCol);</span>
    }
<span class="fc" id="L564">    LOGGER.error(pos, msg);</span>
<span class="fc" id="L565">    LOGGER.print();</span>
<span class="fc" id="L566">    return new CompilerException(&quot;There were syntax errors&quot;);</span>
  }

  private boolean isDigit() {
<span class="pc bpc" id="L570" title="1 of 2 branches missed.">    if (eof) {</span>
<span class="nc" id="L571">      return false;</span>
    }
<span class="fc" id="L573">    return isDigit(input[index]);</span>
  }

  private boolean isDigit(byte c) {
<span class="fc bfc" id="L577" title="All 4 branches covered.">    return '0' &lt;= c &amp;&amp; c &lt;= '9';</span>
  }

  private boolean isAlpha(byte c) {
<span class="fc bfc" id="L581" title="All 10 branches covered.">    return ('A' &lt;= c &amp;&amp; c &lt;= 'Z') || ('a' &lt;= c &amp;&amp; c &lt;= 'z') || c == '_';</span>
  }

  private boolean isAlphaNumeric() {
<span class="pc bpc" id="L585" title="1 of 2 branches missed.">    if (eof) {</span>
<span class="nc" id="L586">      return false;</span>
    }
<span class="fc" id="L588">    return isAlphaNumeric(input[index]);</span>
  }

  private boolean isAlphaNumeric(byte c) {
<span class="fc bfc" id="L592" title="All 4 branches covered.">    return isDigit(c) || isAlpha(c);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>